

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>垃圾收集与LLVM &#8212; LLVM 3.8 文档</title>
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="Writing an LLVM Pass" href="WritingAnLLVMPass.html" />
    <link rel="prev" title="How To Use Instruction Mappings" href="HowToUseInstrMappings.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-78144609-1', 'auto');
  ga('send', 'pageview');
</script>

  </head>
  <body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="WritingAnLLVMPass.html" title="Writing an LLVM Pass"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="HowToUseInstrMappings.html" title="How To Use Instruction Mappings"
             accesskey="P">上一页</a> |</li>
  <li><a href="http://llvm.org/">LLVM 官网</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">LLVM 中文文档</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="garbage-collection-with-llvm">
<h1>垃圾收集与LLVM<a class="headerlink" href="#garbage-collection-with-llvm" title="永久链接至标题">¶</a></h1>
<div class="contents local topic" id="id1">
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">摘要</a></li>
<li><a class="reference internal" href="#quick-start" id="id3">快速开始</a></li>
<li><a class="reference internal" href="#introduction" id="id4">导言</a><ul>
<li><a class="reference internal" href="#what-is-garbage-collection" id="id5">什么是垃圾收集？</a></li>
<li><a class="reference internal" href="#goals-and-non-goals" id="id6">目标和非目标</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-ir-features" id="id7">LLVM IR特性</a><ul>
<li><a class="reference internal" href="#specifying-gc-code-generation-gc" id="id8">指定GC代码的生成: <code class="docutils literal"><span class="pre">gc</span> <span class="pre">&quot;...&quot;</span></code></a></li>
<li><a class="reference internal" href="#gcroot" id="id9">在栈上识别GC根</a><ul>
<li><a class="reference internal" href="#using-gc-statepoint" id="id10">使用 <code class="docutils literal"><span class="pre">gc.statepoint</span></code></a></li>
<li><a class="reference internal" href="#using-llvm-gcwrite" id="id11">使用 <code class="docutils literal"><span class="pre">llvm.gcwrite</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#reading-and-writing-references-in-the-heap" id="id12">在堆中读取和写入引用</a><ul>
<li><a class="reference internal" href="#write-barrier-llvm-gcwrite" id="id13">写屏障： <code class="docutils literal"><span class="pre">llvm.gcwrite</span></code></a></li>
<li><a class="reference internal" href="#read-barrier-llvm-gcread" id="id14">读障碍： <code class="docutils literal"><span class="pre">llvm.gcread</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#built-in-gc-strategies" id="id15">建于GC策略</a><ul>
<li><a class="reference internal" href="#the-shadow-stack-gc" id="id16">影子堆栈GC（Shadow Stack GC）</a></li>
<li><a class="reference internal" href="#the-erlang-and-ocaml-gcs" id="id17">The ‘Erlang’ and ‘Ocaml’ GCs</a></li>
<li><a class="reference internal" href="#the-statepoint-example-gc" id="id18">Statepoint示例GC</a></li>
<li><a class="reference internal" href="#the-coreclr-gc" id="id19">CoreCLR GC</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-gc-strategies" id="id20">自定义GC策略</a><ul>
<li><a class="reference internal" href="#collector-requirements" id="id21">垃圾收集器要求</a></li>
<li><a class="reference internal" href="#implementing-a-collector-plugin" id="id22">实现一个收集器插件</a></li>
<li><a class="reference internal" href="#overview-of-available-features" id="id23">可用特性概述</a></li>
<li><a class="reference internal" href="#computing-stack-maps" id="id24">计算堆栈映射</a></li>
<li><a class="reference internal" href="#initializing-roots-to-null-initroots" id="id25">将根初始化为null：<code class="docutils literal"><span class="pre">InitRoots</span></code></a></li>
<li><a class="reference internal" href="#custom-lowering-of-intrinsics-customroots-customreadbarriers-and-customwritebarriers" id="id26">自定义降级内部函数：<code class="docutils literal"><span class="pre">CustomRoots</span></code>, <code class="docutils literal"><span class="pre">CustomReadBarriers</span></code>, and <code class="docutils literal"><span class="pre">CustomWriteBarriers</span></code></a></li>
<li><a class="reference internal" href="#generating-safe-points-neededsafepoints" id="id27">生成安全点: <code class="docutils literal"><span class="pre">NeededSafePoints</span></code></a></li>
<li><a class="reference internal" href="#emitting-assembly-code-gcmetadataprinter" id="id28">生成汇编代码： <code class="docutils literal"><span class="pre">GCMetadataPrinter</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id29">参考文献</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h2><a class="toc-backref" href="#id2">摘要</a><a class="headerlink" href="#abstract" title="永久链接至标题">¶</a></h2>
<p>本文介绍了如何为LLVM集成一个编译器，构建支持垃圾收集的语言。 <strong>请注意，LLVM本身不提供垃圾收集器</strong> ，您必须自行提供。</p>
</div>
<div class="section" id="quick-start">
<h2><a class="toc-backref" href="#id3">快速开始</a><a class="headerlink" href="#quick-start" title="永久链接至标题">¶</a></h2>
<p>首先，你应该选择一个垃圾收集策略。 LLVM包括许多内置的，但你也可以实现一个自定义的可加载插件。注意，垃圾收集器的策略是在描述LLVM应该如何生成代码，使得生成的代码与垃圾收集器和运行时正确交互，并不是垃圾收集器本身的描述。</p>
<p>接下来，用你选择的收集策略标记您生成的函数。从C++代码中，您可以调用：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">F</span><span class="p">.</span><span class="n">setGC</span><span class="p">(</span><span class="o">&lt;</span><span class="n">collector</span> <span class="n">description</span> <span class="n">name</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
</div>
<p>这将产生像下面的中间代码片段：</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">void</span> <span class="vg">@foo</span><span class="p">()</span> <span class="k">gc</span> <span class="s">&quot;&lt;collector description name&gt;&quot;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>当为你的函数生成LLVM IR时，你将需要：</p>
<ul class="simple">
<li>使用 <code class="docutils literal"><span class="pre">&#64;</span> <span class="pre">llvm.gcread</span></code> 和/或 <code class="docutils literal"><span class="pre">&#64;</span> <span class="pre">llvm.gcwrite</span></code> 代替标准的加载和存储指令。这些内部函数用于表示加载和存储的barriers。如果你收集器不需要这样的barriers，你可以跳过这一步。</li>
<li>使用您的垃圾收集器的运行时库提供的内存分配程序</li>
<li>如果您的垃圾收集器需要它们，可以根据您的运行时的二进制接口生成类型映射。 LLVM不参与这个过程。特别是，LLVM类型系统不适合通过编译器传送这些信息。</li>
<li>插入与垃圾收集器交互所需的任何协调代码。许多收集器需要运行某些代码来定期检查flags并有条件地调用运行时功能。这通常被称为safepoint轮询。（译者注：safepoint的概念是进行垃圾收集动作时，可以安全执行的位置，通常是函数开始前后，所有寄存器中的指针都被保存到栈中时，这时对栈中适当位置扫描，即可获取所有引用的入口点。）</li>
</ul>
<p>您将需要在生成的IR中确定根（例如：引用堆对象的收集器需要知道），让LLVM可以把他们编码进你最终的栈映射表。根据选择的收集器策略，这是可以通过使用  <code class="docutils literal"><span class="pre">&#64;</span> <span class="pre">llvm.gcroot</span></code> 内部函数或 <code class="docutils literal"><span class="pre">gc.statepoint</span></code> 重定位序列来实现。</p>
<p>不要忘记为计算表达式时生成的每个中间值创建一个根。在  <code class="docutils literal"><span class="pre">h(f(),</span> <span class="pre">g())</span></code> 表达式中，如果 <code class="docutils literal"><span class="pre">g()</span></code> 触发了一个收集动作，那么 <code class="docutils literal"><span class="pre">f()</span></code> 的结果也应该可以很容易地被收集。</p>
<p>最后，你需要你的运行时库与生成的可执行程序（对于静态编译）链接或保证对应的符号可以在运行时被链接（对于JIT编译器）。</p>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id4">导言</a><a class="headerlink" href="#introduction" title="永久链接至标题">¶</a></h2>
<div class="section" id="what-is-garbage-collection">
<h3><a class="toc-backref" href="#id5">什么是垃圾收集？</a><a class="headerlink" href="#what-is-garbage-collection" title="永久链接至标题">¶</a></h3>
<p>垃圾收集是一种广泛应用的技术，允许开发者不必关心堆对象的生存期，使得软件更容易构建和维护。许多编程语言依赖垃圾回收的自动内存管理特性。垃圾收集器有以下两种主要形式：保守的和准确的。</p>
<p>保守垃圾收集往往不需要从任一语言或编译的任何特殊的支持：它可以处理非类型安全的编程语言（例如C / C++），并且不需要从编译器获取任何特殊的信息。这款 <a class="reference external" href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">Boehm collector</a> 是一个最先进的保守收集器的例子。</p>
<p>准确垃圾收集需要在运行时（这需要源语言是类型安全在大多数情况下），以确定在程序中的所有指针的能力。在运行时确定的指针，需要编译器的支持，以找到在运行时保持住指针变量的所有地方，包括：<a class="reference internal" href="#gcroot"><span class="std std-ref">processor stack and registers</span></a>。</p>
<p>保守的垃圾收集是有吸引力的，因为它不需要任何特殊的编译器的支持，但它确实有问题。特别是，由于保守的垃圾收集器不能*知道*，在机器一个特定的word可能是一个指针，它不能在堆中移动活动对象（导致不能使用压缩和世代GC算法），它可能偶尔发生内存泄漏，因为某些整数值可能恰好等于某个指针地址。此外，一些激进的编译器转换可能打破保守的垃圾收集器（虽然这些似乎在实践中罕见）。（译者注：保守的垃圾收集器将栈中所有可能的值都当做假想的指针，如果某个不是指针的数字被当做指针，那么将会导致某些可以被回收的元素一直不被回收，如果恰好是某个比较大的树结构的根，则会有大量内存泄露。不过这种收集器之所以实用，就是因为发生特殊情况的概率非常小。）</p>
<p>准确的垃圾收集器不会受到这些问题的困扰，但他们可能会在标量优化时受到影响。特别是，由于在运行时必须能够识别和更新所有在程序中的活指针，一些优化会变得不太有效。然而在实践中，采用积极的垃圾收集技术的局部性和性能优势要胜过任何底层优化的损失。</p>
<p>本文档描述了由LLVM提供支持和维护的准确垃圾收集器的机制和接口。</p>
</div>
<div class="section" id="goals-and-non-goals">
<h3><a class="toc-backref" href="#id6">目标和非目标</a><a class="headerlink" href="#goals-and-non-goals" title="永久链接至标题">¶</a></h3>
<p>LLVM的中间表示为 <a class="reference internal" href="#gc-intrinsics"><span class="std std-ref">garbage collection intrinsics</span></a> 等很多收集器模型提供支持。例如，这些内置的收集器模型被支持：</p>
<ul class="simple">
<li>半空间垃圾收集器</li>
<li>标记 - 清除垃圾收集器</li>
<li>世代垃圾收集</li>
<li>增量式垃圾收集器</li>
<li>并发垃圾收集器</li>
<li>合作式垃圾收集器</li>
<li>参考计数</li>
</ul>
<p>我们希望在LLVM IR上建立对垃圾收集的支持，使其能够支持一大类需要垃圾回收的语言，包括 Scheme，ML，Java，C#，Perl，Python，Lua，Ruby，其他脚本语言等。</p>
<p>需要注意的是LLVM <strong>本身不提供垃圾回收</strong> — 这应该是你的语言的运行时库的一部分。 LLVM提供了描述垃圾收集要求编译器的框架。特别是，LLVM提供用于产生调用堆栈的结构表，轮询safepoint，并发读写屏障（barriers）的支持。您还可以扩展LLVM  - 可以通过一个可加载的 <a class="reference internal" href="#plugin"><span class="std std-ref">code generation plugins</span></a> - 生成一套符合 <em>二进制接口</em> 和 <em>运行时库</em> 的指定代码和数据结构。这类似于，如LLVM和DWARF调试信息之间的关系。所不同的，主要在于缺乏垃圾收集的领域标准—因此需要一个灵活的扩展机制。</p>
<p>与LLVM的GC支持有关的二进制接口有：</p>
<ul class="simple">
<li>在可以安全执行收集代码的位置创建GC safepoints</li>
<li>堆栈映射表的计算。为代码中的每个安全点，堆栈帧中的对象的引用必须确定，使得收集器可以遍历和或许更新它们。</li>
<li>存储堆对象引用的时候发出Write barriers。这些都是世代收集，增量扫描常用的操作。</li>
<li>加载对象引用的时候发出Read barriers。这些对并发收集器交互操作非常有用。</li>
</ul>
<p>还有其他方面的LLVM不能直接解决：</p>
<ul class="simple">
<li>运行时全局根的注册。</li>
<li>运行时栈映射表的注册。</li>
<li>分配内存时使用的函数，触发垃圾收集等。</li>
<li>类型映射表的计算或编译，或在运行时注册该表。这些都是在堆中爬取对象引用所必要的信息。（译者注：类型表对于GC非常重要，因为在堆中，所有内存都是一片连续的数据，你必须能够知道其中哪些是指针，哪些不是，所以必须有所有类型的元数据）</li>
</ul>
<p>一般情况下，LLVM对GC支持不包括可充分解决与IR的其他功能，并且不指定一个特定的二进制接口功能。从有利的一面，这意味着你应该能够LLVM与现有的运行时集成。另一方面，它为新语言的开发者留下了很多工作。我们试图通过提供内置的收集策略的描述，可以与许多常见设计的收集器易于扩展整合，以减轻这部分工作量。如果你还没有，你需要支持特定的二进制接口，我们建议您尝试使用这些内置在收集策略之一。</p>
</div>
</div>
<div class="section" id="llvm-ir-features">
<span id="gc-intrinsics"></span><h2><a class="toc-backref" href="#id7">LLVM IR特性</a><a class="headerlink" href="#llvm-ir-features" title="永久链接至标题">¶</a></h2>
<p>本节介绍所提供的垃圾收集设施 <a class="reference internal" href="LangRef.html"><span class="doc">LLVM intermediate representation</span></a>。 选定的这些IR的确切行为可以参考这里： <a class="reference internal" href="#plugin"><span class="std std-ref">GC strategy description</span></a>。</p>
<div class="section" id="specifying-gc-code-generation-gc">
<h3><a class="toc-backref" href="#id8">指定GC代码的生成: <code class="docutils literal"><span class="pre">gc</span> <span class="pre">&quot;...&quot;</span></code></a><a class="headerlink" href="#specifying-gc-code-generation-gc" title="永久链接至标题">¶</a></h3>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>define &lt;returntype&gt; @name(...) gc &quot;name&quot; { ... }
</pre></div>
</div>
<p>该 <code class="docutils literal"><span class="pre">gc</span></code> 功能属性用于指定所需的GC策略编译器。其方案相当于是 <code class="docutils literal"><span class="pre">Function</span></code> 的 <code class="docutils literal"><span class="pre">setGC</span></code> 方法。</p>
<p>在一个函数上设置  <code class="docutils literal"><span class="pre">gc</span> <span class="pre">&quot;name&quot;</span></code>  会触发搜索来尝试匹配GCStrategy的子类。一些收集器的策略是内置的。您可以添加其他的策略或者使用可加载插件机制，或者直接编写Patching修改LLVM。是被选的GC策略定义了支持GC的代码的确切性质。如果没有找到，编译器会产生一个错误。</p>
<p>指定的GC，在每个函数的基础上，允许LLVM使用不同的垃圾收集算法（或没有）</p>
</div>
<div class="section" id="gcroot">
<span id="identifying-gc-roots-on-the-stack"></span><h3><a class="toc-backref" href="#id9">在栈上识别GC根</a><a class="headerlink" href="#gcroot" title="永久链接至标题">¶</a></h3>
<p>LLVM目前支持在safepoints描述编译代码引用两种不同的机制。 <code class="docutils literal"><span class="pre">llvm.gcroot</span></code> 是旧的机制; <code class="docutils literal"><span class="pre">gc.statepoint</span></code> 已经成为最新特性。目前，您可以选择执行（以 <a class="reference internal" href="#plugin"><span class="std std-ref">GC strategy</span></a>  为基础）。从长期来看，我们可能要么远离 <code class="docutils literal"><span class="pre">llvm.gcroot</span></code> 实现完全迁移或实质上合并它们的实现。请注意，大多数新的开发工作主要集中在 <code class="docutils literal"><span class="pre">gc.statepoint</span></code> 。</p>
<div class="section" id="using-gc-statepoint">
<h4><a class="toc-backref" href="#id10">使用 <code class="docutils literal"><span class="pre">gc.statepoint</span></code></a><a class="headerlink" href="#using-gc-statepoint" title="永久链接至标题">¶</a></h4>
<p><a class="reference internal" href="Statepoints.html"><span class="doc">This page</span></a> 包含了 <code class="docutils literal"><span class="pre">gc.statepoint</span></code> 详细文档。</p>
</div>
<div class="section" id="using-llvm-gcwrite">
<h4><a class="toc-backref" href="#id11">使用 <code class="docutils literal"><span class="pre">llvm.gcwrite</span></code></a><a class="headerlink" href="#using-llvm-gcwrite" title="永久链接至标题">¶</a></h4>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="vg">@llvm.gcroot</span><span class="p">(</span><span class="k">i8</span><span class="p">**</span> <span class="nv">%ptrloc</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%metadata</span><span class="p">)</span>
</pre></div>
</div>
<p>该 <code class="docutils literal"><span class="pre">llvm.gcroot</span></code> 内部命令用来告诉LLVM一个堆栈变量引用了堆中的某个对象，这个引用应该被垃圾收集器所追踪。 生成的代码的确切影响由所选择的函数指定 <a class="reference internal" href="#plugin"><span class="std std-ref">GC strategy</span></a> 。所有调用 <code class="docutils literal"><span class="pre">llvm.gcroot</span></code> 的语句 <strong>必须</strong> 驻留在本函数的第一个基本块内。（译者注：一般编写代码时的临时变量都会在栈上开辟一块内存空间，指针也不例外， <code class="docutils literal"><span class="pre">llvm.gcroot</span></code> 正是指明了这样一种关系，某个栈上的临时变量引用了某个堆上的对象，这样垃圾回收器就可以追踪当前所有被引用的对象，正是从一系列的gcroot开始。必须驻留在第一个基本块中，也是出于安全的考虑，很可能某些操作会导致这个内存加载到寄存器中，没有及时更新回内存，导致垃圾回收器监测了错误的内存地址。）</p>
<p>第一个参数 <strong>必须</strong> 是一个地址，指向指令alloca分配的地址或者alloca的一个bitcast转换。第二包含一个指向应与该指针相关联的元数据，<a href="#id1"><span class="problematic" id="id2">**</span></a>必须**是常量或全局值地址。如果你的目标收集器使用标签，用一个空指针作为元数据。</p>
<p>手动执行静态单赋值（SSA）构建的编译器 <strong>必须</strong> 确保代表GC引用的被存储在alloca分配的地址的SSA值，在每次调用点之前能传递给相应的 <code class="docutils literal"><span class="pre">gcroot</span></code> 并在每次调用后重新加载。采用mem2reg提高代码性能的编译器，只需要对于那些指向GC堆的指针变量添加一个 <code class="docutils literal"><span class="pre">&#64;llvm.gcroot</span></code> 调用。</p>
<p>同样重要的是，标记带有 <code class="docutils literal"><span class="pre">llvm.gcroot</span></code> 的中间变量。例如，考虑 <code class="docutils literal"><span class="pre">h(f(),</span> <span class="pre">g())</span></code> 。 在 <code class="docutils literal"><span class="pre">g()</span></code> 触发一个收集动作时，必须小心 <code class="docutils literal"><span class="pre">f()</span></code> 的返回值发生泄露。请注意，堆栈变量必须在函数的开头部分被初始化并用 <cite>llvm.gcroot`</cite> 标记。（译者注：这个内存泄露的例子是说，如果嵌套函数调用，返回值会存储到了两个临时变量中，必须小心地标记这些用到的中间变量，假设f()返回了一个对象，存储在临时变量a1中，并没有用gcroot标记，那么g()函数内触发了一次垃圾回收，就会因为a1没有被标记为gcroot，对应的内存被标记为没有引用，就可能会被这次垃圾回收给回收掉，造成g()调用结束后，f()的返回值已经不可用了。这样不可用的内存地址传入h函数时必然会发生异常。）</p>
<p>The <code class="docutils literal"><span class="pre">%metadata</span></code> argument can be used to avoid requiring heap objects to have
‘isa’ pointers or tag bits. [<a class="reference internal" href="#appel89">Appel89</a>, <a class="reference internal" href="#goldberg91">Goldberg91</a>, <a class="reference internal" href="#tolmach94">Tolmach94</a>] If specified,
its value will be tracked along with the location of the pointer in the stack
frame.</p>
<p>考虑如下的Java代码片段：</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="o">{</span>
  <span class="n">Object</span> <span class="n">X</span><span class="o">;</span>   <span class="c1">// A null-initialized reference to an object</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>这个块（可能位于一个函数的中间或循环嵌套）可以被编译成这个LLVM代码：</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">Entry:</span>
   <span class="c">;; In the entry block for the function, allocate the</span>
   <span class="c">;; stack space for X, which is an LLVM pointer.</span>
   <span class="nv">%X</span> <span class="p">=</span> <span class="k">alloca</span> <span class="nv">%Object</span><span class="p">*</span>

   <span class="c">;; Tell LLVM that the stack space is a stack root.</span>
   <span class="c">;; Java has type-tags on objects, so we pass null as metadata.</span>
   <span class="nv">%tmp</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="nv">%Object</span><span class="p">**</span> <span class="nv">%X</span> <span class="k">to</span> <span class="k">i8</span><span class="p">**</span>
   <span class="k">call</span> <span class="kt">void</span> <span class="vg">@llvm.gcroot</span><span class="p">(</span><span class="k">i8</span><span class="p">**</span> <span class="nv">%tmp</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">)</span>
   <span class="p">...</span>

   <span class="c">;; &quot;CodeBlock&quot; is the block corresponding to the start</span>
   <span class="c">;;  of the scope above.</span>
<span class="nl">CodeBlock:</span>
   <span class="c">;; Java null-initializes pointers.</span>
   <span class="k">store</span> <span class="nv">%Object</span><span class="p">*</span> <span class="k">null</span><span class="p">,</span> <span class="nv">%Object</span><span class="p">**</span> <span class="nv">%X</span>

   <span class="p">...</span>

   <span class="c">;; As the pointer goes out of scope, store a null value into</span>
   <span class="c">;; it, to indicate that the value is no longer live.</span>
   <span class="k">store</span> <span class="nv">%Object</span><span class="p">*</span> <span class="k">null</span><span class="p">,</span> <span class="nv">%Object</span><span class="p">**</span> <span class="nv">%X</span>
   <span class="p">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="reading-and-writing-references-in-the-heap">
<h3><a class="toc-backref" href="#id12">在堆中读取和写入引用</a><a class="headerlink" href="#reading-and-writing-references-in-the-heap" title="永久链接至标题">¶</a></h3>
<p>当mutator（需要垃圾收集的程序）从堆对象的字段读取指针或写入指针时，需要通知某些收集器。插入这些点的代码片段分别被称为*读屏障*和*写屏障*。需要执行的代码量通常很小，且不在任何计算的关键路径上，因此屏障的整体性能影响是可以接受的。</p>
<p>屏障（Barriers）常常需要访问*对象指针*而非*衍生指针*（这是一个指针字段对象内）。因此，这些内在需要两个指针作为独立完整的参数。在这个片段中，<code class="docutils literal"><span class="pre">%object</span></code> 是对象指针，<code class="docutils literal"><span class="pre">%derived</span></code> 是派生的指针：</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="c">;; An array type.</span>
<span class="nv">%class.Array</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="nv">%class.Object</span><span class="p">,</span> <span class="k">i32</span><span class="p">,</span> <span class="p">[</span><span class="m">0</span> <span class="k">x</span> <span class="nv">%class.Object</span><span class="p">*]</span> <span class="p">}</span>
<span class="p">...</span>

<span class="c">;; Load the object pointer from a gcroot.</span>
<span class="nv">%object</span> <span class="p">=</span> <span class="k">load</span> <span class="nv">%class.Array</span><span class="p">**</span> <span class="nv">%object_addr</span>

<span class="c">;; Compute the derived pointer.</span>
<span class="nv">%derived</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="nv">%object</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%n</span>
</pre></div>
</div>
<p>LLVM不强制制定对象和派生的指针之间的这种关系（虽然具体为 <a class="reference internal" href="#plugin"><span class="std std-ref">collector strategy</span></a> ）。然而，很少有垃圾收集器违反它。</p>
<p>使用这些内在的是自然可选如果目标的GC不需要相应屏障。如果使用他们这样的收集器所使用的GC策略应更换相应的 <code class="docutils literal"><span class="pre">load</span></code> 或 <code class="docutils literal"><span class="pre">store</span></code> 指令的内部调用。</p>
<p>当前设计的一个已知缺陷是屏障内在函数不包括所执行的基础操作的大小或对齐。目前假定操作是指针大小，并且地址对齐被认为是目标机器的默认对齐。</p>
<div class="section" id="write-barrier-llvm-gcwrite">
<h4><a class="toc-backref" href="#id13">写屏障： <code class="docutils literal"><span class="pre">llvm.gcwrite</span></code></a><a class="headerlink" href="#write-barrier-llvm-gcwrite" title="永久链接至标题">¶</a></h4>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="vg">@llvm.gcwrite</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%value</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%object</span><span class="p">,</span> <span class="k">i8</span><span class="p">**</span> <span class="nv">%derived</span><span class="p">)</span>
</pre></div>
</div>
<p>对于写障碍，LLVM提供了 <code class="docutils literal"><span class="pre">llvm.gcwrite</span></code> 固有功能。它具有完全相同的语义非易失性 <code class="docutils literal"><span class="pre">store</span></code> 到派生的指针（第三个参数）。参考：<a class="reference internal" href="#plugin"><span class="std std-ref">GC strategy</span></a> 产生的确切的代码是由函数的选择指定。</p>
<p>许多重要的算法需要编写屏障，包括分代和并发收集器。另外，可以使用写屏障来实现引用计数。</p>
</div>
<div class="section" id="read-barrier-llvm-gcread">
<h4><a class="toc-backref" href="#id14">读障碍： <code class="docutils literal"><span class="pre">llvm.gcread</span></code></a><a class="headerlink" href="#read-barrier-llvm-gcread" title="永久链接至标题">¶</a></h4>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">i8</span><span class="p">*</span> <span class="vg">@llvm.gcread</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%object</span><span class="p">,</span> <span class="k">i8</span><span class="p">**</span> <span class="nv">%derived</span><span class="p">)</span>
</pre></div>
</div>
<p>对于读障碍，LLVM提供了 <code class="docutils literal"><span class="pre">llvm.gcread</span></code> 固有功能。它具有同样的语义从派生的指针（第二个参数）的非易失性``load``。 <a class="reference internal" href="#plugin"><span class="std std-ref">GC strategy</span></a> 产生的确切的代码是由函数的选择指定。</p>
<p>读相对写来说，较少需要障碍，但仍然可能更大程度地影响性能，因为指针读取比写更频繁。</p>
</div>
</div>
</div>
<div class="section" id="built-in-gc-strategies">
<span id="builtin-gc-strategies"></span><span id="plugin"></span><h2><a class="toc-backref" href="#id15">建于GC策略</a><a class="headerlink" href="#built-in-gc-strategies" title="永久链接至标题">¶</a></h2>
<p>LLVM包含对几种垃圾收集器的内置支持。</p>
<div class="section" id="the-shadow-stack-gc">
<h3><a class="toc-backref" href="#id16">影子堆栈GC（Shadow Stack GC）</a><a class="headerlink" href="#the-shadow-stack-gc" title="永久链接至标题">¶</a></h3>
<p>要使用此收集器策略，请使用以下标签标记您的函数：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">F</span><span class="p">.</span><span class="n">setGC</span><span class="p">(</span><span class="s">&quot;shadow-stack&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>不同于依靠合作代码生成器来编译堆栈映射表的很多GC算法，该算法谨慎地保持着堆根链表 [<a class="reference internal" href="#henderson02"><span class="std std-ref">Henderson2002</span></a>]。这种所谓的 “shadow stack” 是机器堆栈的一个镜像。保持这种数据结构比使用编译成可执行固定数据堆栈映射慢，但有一个显著可移植性的优点，因为它不需要目标代码生成器的特殊支持，并且不需要棘手的特定平台代码，来抓取本机堆栈。</p>
<p>这种简洁性和便携性的代价是：</p>
<ul class="simple">
<li>每次函数调用的开销很高。</li>
<li>不是线程安全的。</li>
</ul>
<p>不过，这是一个简单的入门方法。编译器和运行库启动并运行后，编写一个 <a class="reference internal" href="#plugin"><span class="std std-ref">plugin</span></a> 可以让您利用LLVM的更高级GC功能&lt;collector-algos&gt;来提高性能。</p>
<p>该影子堆栈算法，并不需要编写内存分配算法。一个半空间收集器或构建在 <a href="#id1"><span class="problematic" id="id2">``</span></a>malloc` 上的分配器就是一个很好的入手点，可以用很少的代码来实现。</p>
<p>但是，当需要收集时，您的运行时需要遍历堆栈根，因此需要与影子堆栈集成。幸运的是，这样做很简单。 （这段代码被大量的评论来帮助你理解数据结构，但是只有20行有意义的代码。）</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">/// @brief The map for a single function&#39;s stack frame.  One of these is</span>
<span class="c1">///        compiled as constant data into the executable for each function.</span>
<span class="c1">///</span>
<span class="c1">/// Storage of metadata values is elided if the %metadata parameter to</span>
<span class="c1">/// @llvm.gcroot is null.</span>
<span class="k">struct</span> <span class="n">FrameMap</span> <span class="p">{</span>
  <span class="kt">int32_t</span> <span class="n">NumRoots</span><span class="p">;</span>    <span class="c1">//&lt; Number of roots in stack frame.</span>
  <span class="kt">int32_t</span> <span class="n">NumMeta</span><span class="p">;</span>     <span class="c1">//&lt; Number of metadata entries.  May be &lt; NumRoots.</span>
  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">Meta</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">//&lt; Metadata for each root.</span>
<span class="p">};</span>

<span class="c1">/// @brief A link in the dynamic shadow stack.  One of these is embedded in</span>
<span class="c1">///        the stack frame of each function on the call stack.</span>
<span class="k">struct</span> <span class="n">StackEntry</span> <span class="p">{</span>
  <span class="n">StackEntry</span> <span class="o">*</span><span class="n">Next</span><span class="p">;</span>    <span class="c1">//&lt; Link to next stack entry (the caller&#39;s).</span>
  <span class="k">const</span> <span class="n">FrameMap</span> <span class="o">*</span><span class="n">Map</span><span class="p">;</span> <span class="c1">//&lt; Pointer to constant FrameMap.</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">Roots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>      <span class="c1">//&lt; Stack roots (in-place array).</span>
<span class="p">};</span>

<span class="c1">/// @brief The head of the singly-linked list of StackEntries.  Functions push</span>
<span class="c1">///        and pop onto this in their prologue and epilogue.</span>
<span class="c1">///</span>
<span class="c1">/// Since there is only a global list, this technique is not threadsafe.</span>
<span class="n">StackEntry</span> <span class="o">*</span><span class="n">llvm_gc_root_chain</span><span class="p">;</span>

<span class="c1">/// @brief Calls Visitor(root, meta) for each GC root on the stack.</span>
<span class="c1">///        root and meta are exactly the values passed to</span>
<span class="c1">///        @llvm.gcroot.</span>
<span class="c1">///</span>
<span class="c1">/// Visitor could be a function to recursively mark live objects.  Or it</span>
<span class="c1">/// might copy them to another heap or generation.</span>
<span class="c1">///</span>
<span class="c1">/// @param Visitor A function to invoke for every GC root on the stack.</span>
<span class="kt">void</span> <span class="nf">visitGCRoots</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">Visitor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">**</span><span class="n">Root</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">Meta</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">StackEntry</span> <span class="o">*</span><span class="n">R</span> <span class="o">=</span> <span class="n">llvm_gc_root_chain</span><span class="p">;</span> <span class="n">R</span><span class="p">;</span> <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// For roots [0, NumMeta), the metadata pointer is in the FrameMap.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">e</span> <span class="o">=</span> <span class="n">R</span><span class="o">-&gt;</span><span class="n">Map</span><span class="o">-&gt;</span><span class="n">NumMeta</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="n">Visitor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">R</span><span class="o">-&gt;</span><span class="n">Roots</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">R</span><span class="o">-&gt;</span><span class="n">Map</span><span class="o">-&gt;</span><span class="n">Meta</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="c1">// For roots [NumMeta, NumRoots), the metadata pointer is null.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">e</span> <span class="o">=</span> <span class="n">R</span><span class="o">-&gt;</span><span class="n">Map</span><span class="o">-&gt;</span><span class="n">NumRoots</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="n">Visitor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">R</span><span class="o">-&gt;</span><span class="n">Roots</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="the-erlang-and-ocaml-gcs">
<h3><a class="toc-backref" href="#id17">The ‘Erlang’ and ‘Ocaml’ GCs</a><a class="headerlink" href="#the-erlang-and-ocaml-gcs" title="永久链接至标题">¶</a></h3>
<p>LLVM附带两个利用 <code class="docutils literal"><span class="pre">gcroot</span></code> 机制的示例收集器。据我们所知，这些实际上并没有被任何语言运行时使用，但是它们为有兴趣编写  <code class="docutils literal"><span class="pre">gcroot</span></code> 兼容GC的插件的人提供了一个合理的起点。特别是，这些是树型示例中唯一如何使用gcroot策略生成自定义二进制堆栈映射格式的示例。</p>
<p>因为顾名思义，所产生的二进制格式是为了模拟Erlang和OCaml编译器分别使用的格式。</p>
</div>
<div class="section" id="the-statepoint-example-gc">
<span id="statepoint-example-gc"></span><h3><a class="toc-backref" href="#id18">Statepoint示例GC</a><a class="headerlink" href="#the-statepoint-example-gc" title="永久链接至标题">¶</a></h3>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">F</span><span class="p">.</span><span class="n">setGC</span><span class="p">(</span><span class="s">&quot;statepoint-example&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>这个GC提供了一个例子，说明如何使用gc.statepoint提供的基础结构。这个示例GC兼容 <a class="reference internal" href="Statepoints.html#placesafepoints"><span class="std std-ref">PlaceSafepoints</span></a> 和 <a class="reference internal" href="Statepoints.html#rewritestatepointsforgc"><span class="std std-ref">RewriteStatepointsForGC</span></a> 实用Pass，可以简化gc.statepoint序列的插入。如果你需要在 <code class="docutils literal"><span class="pre">gc.statepoints</span></code> 机制周围建立一个自定义GC策略，建议你使用这个策略作为起点。</p>
<p>此GC策略不支持读取或写入屏障。结果，这些内部函数被降级为正常的加载和存储。</p>
<p>这个GC策略生成的堆栈映射格式可以在以下文件的 <a class="reference internal" href="StackMaps.html#stackmap-section"><span class="std std-ref">Stack Map Section</span></a> 中找到 ref:<cite>here &lt;statepoint-stackmap-format&gt;</cite> 。这种格式旨在成为LLVM向前发展的标准格式。</p>
</div>
<div class="section" id="the-coreclr-gc">
<h3><a class="toc-backref" href="#id19">CoreCLR GC</a><a class="headerlink" href="#the-coreclr-gc" title="永久链接至标题">¶</a></h3>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">F</span><span class="p">.</span><span class="n">setGC</span><span class="p">(</span><span class="s">&quot;coreclr&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>这个GC利用gc.statepoint机制来支持  <a class="reference external" href="https://github.com/dotnet/coreclr">CoreCLR</a>   运行时。</p>
<p>这个GC策略的支持是一项正在进行的工作。 这个策略与 <a class="reference internal" href="#statepoint-example-gc"><span class="std std-ref">statepoint-example GC</span></a> 在某些方面有所不同，如：</p>
<ul class="simple">
<li>内部指针的基本指针没有明确的跟踪和报告。</li>
<li>编码堆栈映射使用不同的格式。</li>
<li>安全点轮询仅在回送边缘之前和尾部呼叫之前需要（在函数入口处不需要）。</li>
</ul>
</div>
</div>
<div class="section" id="custom-gc-strategies">
<h2><a class="toc-backref" href="#id20">自定义GC策略</a><a class="headerlink" href="#custom-gc-strategies" title="永久链接至标题">¶</a></h2>
<p>如果内置的GC策略描述中没有一个满足您的需求，则需要定义一个自定义GCStrategy，并可能需要定制LLVM通道来执行降低操作。从哪里开始定义定制的GCStrategy最好的例子就是看看内置的策略之一。</p>
<p>您可以将这些附加代码构建为可加载的插件库。如果您只需要启用内置功能的不同组合，则可加载插件就足够了，但是如果您需要提供自定义降级通道，则需要构建LLVM的修补版本。如果您认为您需要修补版本，请咨询llvm-dev的建议。可能有一个简单的方法，我们可以扩展支持，使其为您的用例工作，而无需自定义生成。</p>
<div class="section" id="collector-requirements">
<h3><a class="toc-backref" href="#id21">垃圾收集器要求</a><a class="headerlink" href="#collector-requirements" title="永久链接至标题">¶</a></h3>
<p>您应该能够使用用包含以下元素的任何现有的垃圾收集器库：</p>
<ol class="arabic simple">
<li>一个内存分配器，它提供了编译后的代码可以调用的分配函数。</li>
<li>堆栈映射的二进制格式。堆栈映射在一个safepoint描述引用的位置，在精确的收集器中用于标识机器堆栈上的堆栈帧内的引用。请注意，保守扫描堆栈的收集器不需要这样的结构。</li>
<li>一个堆栈搜寻器发现调用堆栈上的函数，并枚举堆栈映射中列出的每个调用点的引用。</li>
<li>用于识别全局位置（例如全局变量）中的引用的机制。</li>
<li>如果您的收集器需要它们，您的收集器的LLVM IR实施会加载和存储屏障。请注意，由于许多垃圾收集器完全不需要任何屏障，LLVM默认将这些障碍降至正常的装载和存储，除非您另有安排。</li>
</ol>
</div>
<div class="section" id="implementing-a-collector-plugin">
<h3><a class="toc-backref" href="#id22">实现一个收集器插件</a><a class="headerlink" href="#implementing-a-collector-plugin" title="永久链接至标题">¶</a></h3>
<p>用户代码指定哪个GC代码生成与 <code class="docutils literal"><span class="pre">gc</span></code> 函数属性一起使用，或者等同于 <code class="docutils literal"><span class="pre">Function</span></code> 的 <code class="docutils literal"><span class="pre">setGC</span></code> 方法。</p>
<p>要实现一个GC插件，需要继承 <code class="docutils literal"><span class="pre">llvm</span> <span class="pre">::</span> <span class="pre">GCStrategy</span></code> ，这可以通过几行样板代码完成。 LLVM的基础架构提供了对几个重要算法的访问。对于一个没有争议的收集器，剩下的可能是编译LLVM的计算堆栈映射到汇编代码（使用运行时库期望的二进制表示）。这可以在大约100行代码中完成。</p>
<p>这不是实现垃圾收集堆或垃圾收集器本身的适当位置。该代码应该存在于该语言的运行时库中。编译器插件负责生成符合库定义的二进制接口的代码，最基本的是 <a class="reference internal" href="#stack-map"><span class="std std-ref">stack map</span></a>。</p>
<p>要继承“<a href="#id1"><span class="problematic" id="id2">`</span></a>llvm :: GCStrategy”并将其注册到编译器：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// lib/MyGC/MyGC.cpp - Example LLVM GC plugin</span>

<span class="cp">#include</span> <span class="cpf">&quot;llvm/CodeGen/GCStrategy.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/CodeGen/GCMetadata.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/Support/Compiler.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">LLVM_LIBRARY_VISIBILITY</span> <span class="nl">MyGC</span> <span class="p">:</span> <span class="k">public</span> <span class="n">GCStrategy</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">MyGC</span><span class="p">()</span> <span class="p">{}</span>
  <span class="p">};</span>

  <span class="n">GCRegistry</span><span class="o">::</span><span class="n">Add</span><span class="o">&lt;</span><span class="n">MyGC</span><span class="o">&gt;</span>
  <span class="n">X</span><span class="p">(</span><span class="s">&quot;mygc&quot;</span><span class="p">,</span> <span class="s">&quot;My bespoke garbage collector.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个示例收集器什么都不做。进一步来说：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.gcread</span></code> calls are replaced with the corresponding <code class="docutils literal"><span class="pre">load</span></code>
instruction.</li>
<li><code class="docutils literal"><span class="pre">llvm.gcwrite</span></code> calls are replaced with the corresponding <code class="docutils literal"><span class="pre">store</span></code>
instruction.</li>
<li>没有安全点（safepoint）被添加到代码。</li>
<li>堆栈映射不会编译到可执行文件中。</li>
</ul>
<p>使用LLVM makefiles，可以使用简单的makefile将此代码编译为插件：</p>
<div class="highlight-make"><div class="highlight"><pre><span></span><span class="c"># lib/MyGC/Makefile</span>

<span class="nv">LEVEL</span> <span class="o">:=</span> ../..
<span class="nv">LIBRARYNAME</span> <span class="o">=</span> MyGC
<span class="nv">LOADABLE_MODULE</span> <span class="o">=</span> <span class="m">1</span>

<span class="cp">include $(LEVEL)/Makefile.common</span>
</pre></div>
</div>
<p>一旦插件被编译，使用它的代码可以使用 <code class="docutils literal"><span class="pre">llc</span> <span class="pre">-load</span> <span class="pre">=</span> <span class="pre">MyGC.so</span></code> 来编译（尽管MyGC.so可能有一些其他特定于平台的扩展）：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ cat sample.ll
define void @f() gc &quot;mygc&quot; {
entry:
  ret void
}
$ llvm-as &lt; sample.ll | llc -load=MyGC.so
</pre></div>
</div>
<p>还可以将收集器插件静态链接到工具，如特定于语言的编译器前端。</p>
</div>
<div class="section" id="overview-of-available-features">
<span id="collector-algos"></span><h3><a class="toc-backref" href="#id23">可用特性概述</a><a class="headerlink" href="#overview-of-available-features" title="永久链接至标题">¶</a></h3>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>GCStrategy``提供了一系列功能，通过它，插件可以做有用的工作。其中一些是回调，一些是可以启用，禁用或定制的算法。下表总结了已经支持（和计划支持）的功能，并将它们与通常需要它们的垃圾收集技术相关联。</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="7%" />
<col width="9%" />
<col width="11%" />
<col width="8%" />
<col width="10%" />
<col width="15%" />
<col width="11%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Algorithm</th>
<th class="head">Done</th>
<th class="head">Shadow
stack</th>
<th class="head">refcount</th>
<th class="head">mark-
sweep</th>
<th class="head">copying</th>
<th class="head">incremental</th>
<th class="head">threaded</th>
<th class="head">concurrent</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>stack map</td>
<td>✔</td>
<td>&#160;</td>
<td>&#160;</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
</tr>
<tr class="row-odd"><td>initialize
roots</td>
<td>✔</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
</tr>
<tr class="row-even"><td>derived
pointers</td>
<td>NO</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td><strong>N</strong>*</td>
<td><strong>N</strong>*</td>
</tr>
<tr class="row-odd"><td><strong>custom
lowering</strong></td>
<td>✔</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><em>gcroot</em></td>
<td>✔</td>
<td>✘</td>
<td>✘</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><em>gcwrite</em></td>
<td>✔</td>
<td>&#160;</td>
<td>✘</td>
<td>&#160;</td>
<td>&#160;</td>
<td>✘</td>
<td>&#160;</td>
<td>✘</td>
</tr>
<tr class="row-even"><td><em>gcread</em></td>
<td>✔</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>✘</td>
</tr>
<tr class="row-odd"><td><strong>safe
points</strong></td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><em>in
calls</em></td>
<td>✔</td>
<td>&#160;</td>
<td>&#160;</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
</tr>
<tr class="row-odd"><td><em>before
calls</em></td>
<td>✔</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>✘</td>
<td>✘</td>
</tr>
<tr class="row-even"><td><em>for
loops</em></td>
<td>NO</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td><strong>N</strong></td>
<td><strong>N</strong></td>
</tr>
<tr class="row-odd"><td><em>before
escape</em></td>
<td>✔</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>✘</td>
<td>✘</td>
</tr>
<tr class="row-even"><td>emit code
at safe
points</td>
<td>NO</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td><strong>N</strong></td>
<td><strong>N</strong></td>
</tr>
<tr class="row-odd"><td><strong>output</strong></td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><em>assembly</em></td>
<td>✔</td>
<td>&#160;</td>
<td>&#160;</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
</tr>
<tr class="row-odd"><td><em>JIT</em></td>
<td>NO</td>
<td>&#160;</td>
<td>&#160;</td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
</tr>
<tr class="row-even"><td><em>obj</em></td>
<td>NO</td>
<td>&#160;</td>
<td>&#160;</td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
</tr>
<tr class="row-odd"><td>live
analysis</td>
<td>NO</td>
<td>&#160;</td>
<td>&#160;</td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
</tr>
<tr class="row-even"><td>register
map</td>
<td>NO</td>
<td>&#160;</td>
<td>&#160;</td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
<td><strong>?</strong></td>
</tr>
<tr class="row-odd"><td colspan="9">* Derived pointers only pose a hasard to copying collections.</td>
</tr>
<tr class="row-even"><td colspan="9"><a href="#id1"><span class="problematic" id="id2">**</span></a>？<a href="#id3"><span class="problematic" id="id4">**</span></a>表示可用时，有价值的功能。</td>
</tr>
</tbody>
</table>
<p>需要明确的是，上面的收集技术被定义为：</p>
<dl class="docutils">
<dt>影子堆栈（Shadow Stack）</dt>
<dd>增变器仔细维护了一个堆栈根的链表。</dd>
<dt>引用计数</dt>
<dd>增变器维护每个对象的引用计数，并在计数降到零时释放对象。</dd>
<dt>标记-清扫算法</dt>
<dd>当堆空间用尽时，收集器将从根开始标记可到达的对象，然后在扫描阶段释放不可达对象。</dd>
<dt>拷贝式垃圾收集</dt>
<dd>随着可达性分析的进行，收集器将对象从一个堆区域复制到另一个堆区域，并将它们压缩在过程中。复制收集器可实现高效的“凹凸指针”分配，并可改善参考的局部性。</dd>
<dt>增量回收</dt>
<dd>（包括世代收集器）增量收集器通常具有复制收集器的所有属性（不管堆是否压缩），但是增加了需要编写屏障的复杂性。</dd>
<dt>Threaded</dt>
<dd>表示多线程的增变器;在开始可达性分析之前，收集器必须仍然停止增变器（“停止整个世界”）。停止多线程增变是一个复杂的问题。它通常要求运行时具有高度特定于平台的代码，并在安全的地方生产精心设计的机器代码。</dd>
<dt>concurrent=50</dt>
<dd>在这种技术中，增变器和收集器同时运行，其目标是消除暂停时间。在一个 <em>合作</em> 收集器中，增变器进一步援助收集应暂停发生，允许收集利用多处理器主机。Threaded收集器的“停止世界”问题通常仍然存在有限的程度。复杂的标记算法是必要的。阅读屏障可能是必要的。</dd>
</dl>
<p>如矩阵所示，LLVM的垃圾收集基础结构已经适用于各种各样的收集器，但目前不扩展到多线程程序。由于这是热门话题，很可能将在未来加入更多种收集器。</p>
</div>
<div class="section" id="computing-stack-maps">
<span id="stack-map"></span><h3><a class="toc-backref" href="#id24">计算堆栈映射</a><a class="headerlink" href="#computing-stack-maps" title="永久链接至标题">¶</a></h3>
<p>LLVM自动计算堆栈映射。<code class="docutils literal"><span class="pre">GCStrategy</span></code> 最重要的特性之一就是将这些信息编译成运行时库期望的二进制表示形式的可执行文件。</p>
<p>堆栈图由模块中每个函数中每个GC根的位置和标识组成。对于每个根：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">RootNum</span></code>: 根的索引。</li>
<li><code class="docutils literal"><span class="pre">StackOffset</span></code>: 对象相对于帧指针的偏移量。</li>
<li><code class="docutils literal"><span class="pre">RootMetadata</span></code>: 作为 <code class="docutils literal"><span class="pre">％metadata</span></code> 参数来传递给 <code class="docutils literal"><span class="pre">&#64;</span> <span class="pre">llvm.gcroot</span></code> 内在的值。</li>
</ul>
<p>另外，对于整个函数：</p>
<ul class="simple">
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">getFrameSize()</span></code>: 函数的初始堆栈框架的整体大小，</dt>
<dd>不考虑任何动态分配。</dd>
</dl>
</li>
<li><code class="docutils literal"><span class="pre">roots_size()</span></code>: 函数中根的数量。</li>
</ul>
<p>要访问堆栈映射，可以使用：<code class="docutils literal"><span class="pre">GCFunctionMetadata::roots_begin()</span></code> 和 <code class="docutils literal"><span class="pre">end()</span></code> ，参见 <a class="reference internal" href="#assembly"><span class="std std-ref">GCMetadataPrinter</span></a></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(),</span> <span class="n">E</span> <span class="o">=</span> <span class="n">end</span><span class="p">();</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">E</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">GCFunctionInfo</span> <span class="o">*</span><span class="n">FI</span> <span class="o">=</span> <span class="o">*</span><span class="n">I</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">FrameSize</span> <span class="o">=</span> <span class="n">FI</span><span class="o">-&gt;</span><span class="n">getFrameSize</span><span class="p">();</span>
  <span class="kt">size_t</span> <span class="n">RootCount</span> <span class="o">=</span> <span class="n">FI</span><span class="o">-&gt;</span><span class="n">roots_size</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">GCFunctionInfo</span><span class="o">::</span><span class="n">roots_iterator</span> <span class="n">RI</span> <span class="o">=</span> <span class="n">FI</span><span class="o">-&gt;</span><span class="n">roots_begin</span><span class="p">(),</span>
                                      <span class="n">RE</span> <span class="o">=</span> <span class="n">FI</span><span class="o">-&gt;</span><span class="n">roots_end</span><span class="p">();</span>
                                      <span class="n">RI</span> <span class="o">!=</span> <span class="n">RE</span><span class="p">;</span> <span class="o">++</span><span class="n">RI</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">RootNum</span> <span class="o">=</span> <span class="n">RI</span><span class="o">-&gt;</span><span class="n">Num</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">RootStackOffset</span> <span class="o">=</span> <span class="n">RI</span><span class="o">-&gt;</span><span class="n">StackOffset</span><span class="p">;</span>
    <span class="n">Constant</span> <span class="o">*</span><span class="n">RootMetadata</span> <span class="o">=</span> <span class="n">RI</span><span class="o">-&gt;</span><span class="n">Metadata</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果在代码生成之前通过自定义降级Pass去除了 <code class="docutils literal"><span class="pre">llvm.gcroot</span></code>  内部函数，LLVM将计算一个空的堆栈映射。这可能对实现引用计数或影子堆栈的收集器插件有用。</p>
</div>
<div class="section" id="initializing-roots-to-null-initroots">
<span id="init-roots"></span><h3><a class="toc-backref" href="#id25">将根初始化为null：<code class="docutils literal"><span class="pre">InitRoots</span></code></a><a class="headerlink" href="#initializing-roots-to-null-initroots" title="永久链接至标题">¶</a></h3>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">MyGC</span><span class="o">::</span><span class="n">MyGC</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">InitRoots</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>设置后，LLVM将在进入该函数时自动将每个根初始化为 <code class="docutils literal"><span class="pre">null</span></code> 。这可以防止GC的扫描阶段访问未初始化的指针，这几乎肯定会导致崩溃。这个初始化发生在自定义降低之前，所以两者可以一起使用。</p>
<p>由于LLVM尚未计算活跃度信息，因此无法区分未初始化的堆栈根与已初始化的堆。所以，这个功能应该被所有的GC插件使用。它是默认启用的。</p>
</div>
<div class="section" id="custom-lowering-of-intrinsics-customroots-customreadbarriers-and-customwritebarriers">
<h3><a class="toc-backref" href="#id26">自定义降级内部函数：<code class="docutils literal"><span class="pre">CustomRoots</span></code>, <code class="docutils literal"><span class="pre">CustomReadBarriers</span></code>, and <code class="docutils literal"><span class="pre">CustomWriteBarriers</span></code></a><a class="headerlink" href="#custom-lowering-of-intrinsics-customroots-customreadbarriers-and-customwritebarriers" title="永久链接至标题">¶</a></h3>
<p>对于使用屏障或堆栈根的异常处理的GC，这些标志允许收集器执行LLVM IR的任意转换：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyGC</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GCStrategy</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">MyGC</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">CustomRoots</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">CustomReadBarriers</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">CustomWriteBarriers</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>如果设置了这些标志中的任何一个，则LLVM会禁止相应内部函数的默认降低。相反，您必须提供一个自定义Pass，以根据需要降低内部函数。如果您已经选择了自定义降低某个特定的内在因素，那么您必须**删除选择加入到GC中的相应内在函数的所有实例。这种传球的最好的例子是ShadowStackGC，它是ShadowStackGCLowering传球。</p>
<p>目前没有办法在没有构建LLVM的定制副本的情况下注册这样的自定义降级Pass。</p>
</div>
<div class="section" id="generating-safe-points-neededsafepoints">
<span id="safe-points"></span><h3><a class="toc-backref" href="#id27">生成安全点: <code class="docutils literal"><span class="pre">NeededSafePoints</span></code></a><a class="headerlink" href="#generating-safe-points-neededsafepoints" title="永久链接至标题">¶</a></h3>
<p>LLVM可以计算四种安全点：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">GC</span> <span class="p">{</span>
  <span class="c1">/// PointKind - The type of a collector-safe point.</span>
  <span class="c1">///</span>
  <span class="k">enum</span> <span class="n">PointKind</span> <span class="p">{</span>
    <span class="n">Loop</span><span class="p">,</span>    <span class="c1">//&lt; Instr is a loop (backwards branch).</span>
    <span class="n">Return</span><span class="p">,</span>  <span class="c1">//&lt; Instr is a return instruction.</span>
    <span class="n">PreCall</span><span class="p">,</span> <span class="c1">//&lt; Instr is a call instruction.</span>
    <span class="n">PostCall</span> <span class="c1">//&lt; Instr is the return address of a call.</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>收集器可以通过设置NeededSafePoints掩码来请求这四者的任意组合：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">MyGC</span><span class="o">::</span><span class="n">MyGC</span><span class="p">()</span>  <span class="p">{</span>
  <span class="n">NeededSafePoints</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">GC</span><span class="o">::</span><span class="n">Loop</span>
                   <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">GC</span><span class="o">::</span><span class="n">Return</span>
                   <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">GC</span><span class="o">::</span><span class="n">PreCall</span>
                   <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">GC</span><span class="o">::</span><span class="n">PostCall</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然后它可以使用以下例程来访问安全点。</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(),</span> <span class="n">E</span> <span class="o">=</span> <span class="n">end</span><span class="p">();</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">E</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">GCFunctionInfo</span> <span class="o">*</span><span class="n">MD</span> <span class="o">=</span> <span class="o">*</span><span class="n">I</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">PointCount</span> <span class="o">=</span> <span class="n">MD</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">GCFunctionInfo</span><span class="o">::</span><span class="n">iterator</span> <span class="n">PI</span> <span class="o">=</span> <span class="n">MD</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span>
                                <span class="n">PE</span> <span class="o">=</span> <span class="n">MD</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="n">PI</span> <span class="o">!=</span> <span class="n">PE</span><span class="p">;</span> <span class="o">++</span><span class="n">PI</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GC</span><span class="o">::</span><span class="n">PointKind</span> <span class="n">PointKind</span> <span class="o">=</span> <span class="n">PI</span><span class="o">-&gt;</span><span class="n">Kind</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">PointNum</span> <span class="o">=</span> <span class="n">PI</span><span class="o">-&gt;</span><span class="n">Num</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>几乎每个收集器要求 <code class="docutils literal"><span class="pre">PostCall</span></code> 安全点，因为这些对应于函数在调用子例程期间暂停的时刻。</p>
<p>多线程程序通常需要使用 <code class="docutils literal"><span class="pre">Loop</span></code> 安全点来保证应用程序在有限的时间内到达安全点，即使它正在执行一个不包含函数调用的长时间运行的循环。</p>
<p>螺纹收集器也可能需要 <code class="docutils literal"><span class="pre">Return</span></code> 和 <code class="docutils literal"><span class="pre">PreCall</span></code> 安全点来实现使用自修改代码来“停止世界”的技术，在那里重要的是程序不能在没有达到安全点的情况下退出函数（因为只有最上面的功能已被修复）。</p>
</div>
<div class="section" id="emitting-assembly-code-gcmetadataprinter">
<span id="assembly"></span><h3><a class="toc-backref" href="#id28">生成汇编代码： <code class="docutils literal"><span class="pre">GCMetadataPrinter</span></code></a><a class="headerlink" href="#emitting-assembly-code-gcmetadataprinter" title="永久链接至标题">¶</a></h3>
<p>LLVM允许插件在模块的汇编代码的其余部分之前和之后打印任意汇编代码。在模块结束时，GC可以将LLVM堆栈映射编译为汇编代码。 （起初，这个信息还没有计算出来。）</p>
<p>由于AsmWriter和CodeGen是LLVM的独立组件，因此为打印汇编代码， <code class="docutils literal"><span class="pre">GCMetadaPrinter</span></code> 和 <code class="docutils literal"><span class="pre">GCMetadataPrinterRegistry</span></code> 提供了独立的抽象基类和注册表。如果 <code class="docutils literal"><span class="pre">GCStrategy</span></code> 设置了  <code class="docutils literal"><span class="pre">UsesMetadata</span></code> ，AsmWriter将查找这样的子类：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">MyGC</span><span class="o">::</span><span class="n">MyGC</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">UsesMetadata</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这种分离式设计可以让只含有JIT的编译器缩减体积。</p>
<p>请注意，LLVM目前没有类似的API来支持JIT中的代码生成，也没有使用对象写入器。</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// lib/MyGC/MyGCPrinter.cpp - Example LLVM GC printer</span>

<span class="cp">#include</span> <span class="cpf">&quot;llvm/CodeGen/GCMetadataPrinter.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/Support/Compiler.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">LLVM_LIBRARY_VISIBILITY</span> <span class="nl">MyGCPrinter</span> <span class="p">:</span> <span class="k">public</span> <span class="n">GCMetadataPrinter</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">beginAssembly</span><span class="p">(</span><span class="n">AsmPrinter</span> <span class="o">&amp;</span><span class="n">AP</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">finishAssembly</span><span class="p">(</span><span class="n">AsmPrinter</span> <span class="o">&amp;</span><span class="n">AP</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="n">GCMetadataPrinterRegistry</span><span class="o">::</span><span class="n">Add</span><span class="o">&lt;</span><span class="n">MyGCPrinter</span><span class="o">&gt;</span>
  <span class="n">X</span><span class="p">(</span><span class="s">&quot;mygc&quot;</span><span class="p">,</span> <span class="s">&quot;My bespoke garbage collector.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>收集器应使用“AsmPrinter”来打印便携式汇编代码。收集器本身包含整个模块的堆栈映射，可以使用自己的 <code class="docutils literal"><span class="pre">begin()</span></code> 和 <code class="docutils literal"><span class="pre">end()</span></code> 方法访问GCFunctionInfo。这是一个真实的例子：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;llvm/CodeGen/AsmPrinter.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/IR/Function.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/IR/DataLayout.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/Target/TargetAsmInfo.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/Target/TargetMachine.h&quot;</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">MyGCPrinter</span><span class="o">::</span><span class="n">beginAssembly</span><span class="p">(</span><span class="n">AsmPrinter</span> <span class="o">&amp;</span><span class="n">AP</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Nothing to do.</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">MyGCPrinter</span><span class="o">::</span><span class="n">finishAssembly</span><span class="p">(</span><span class="n">AsmPrinter</span> <span class="o">&amp;</span><span class="n">AP</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">OS</span> <span class="o">=</span> <span class="n">AP</span><span class="p">.</span><span class="n">OutStreamer</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">IntPtrSize</span> <span class="o">=</span> <span class="n">AP</span><span class="p">.</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtargetImpl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getDataLayout</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getPointerSize</span><span class="p">();</span>

  <span class="c1">// Put this in the data section.</span>
  <span class="n">OS</span><span class="p">.</span><span class="n">SwitchSection</span><span class="p">(</span><span class="n">AP</span><span class="p">.</span><span class="n">getObjFileLowering</span><span class="p">().</span><span class="n">getDataSection</span><span class="p">());</span>

  <span class="c1">// For each function...</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">iterator</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(),</span> <span class="n">FE</span> <span class="o">=</span> <span class="n">end</span><span class="p">();</span> <span class="n">FI</span> <span class="o">!=</span> <span class="n">FE</span><span class="p">;</span> <span class="o">++</span><span class="n">FI</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GCFunctionInfo</span> <span class="o">&amp;</span><span class="n">MD</span> <span class="o">=</span> <span class="o">**</span><span class="n">FI</span><span class="p">;</span>

    <span class="c1">// A compact GC layout. Emit this data structure:</span>
    <span class="c1">//</span>
    <span class="c1">// struct {</span>
    <span class="c1">//   int32_t PointCount;</span>
    <span class="c1">//   void *SafePointAddress[PointCount];</span>
    <span class="c1">//   int32_t StackFrameSize; // in words</span>
    <span class="c1">//   int32_t StackArity;</span>
    <span class="c1">//   int32_t LiveCount;</span>
    <span class="c1">//   int32_t LiveOffsets[LiveCount];</span>
    <span class="c1">// } __gcmap_&lt;FUNCTIONNAME&gt;;</span>

    <span class="c1">// Align to address width.</span>
    <span class="n">AP</span><span class="p">.</span><span class="n">EmitAlignment</span><span class="p">(</span><span class="n">IntPtrSize</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">3</span><span class="p">);</span>

    <span class="c1">// Emit PointCount.</span>
    <span class="n">OS</span><span class="p">.</span><span class="n">AddComment</span><span class="p">(</span><span class="s">&quot;safe point count&quot;</span><span class="p">);</span>
    <span class="n">AP</span><span class="p">.</span><span class="n">EmitInt32</span><span class="p">(</span><span class="n">MD</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="c1">// And each safe point...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">GCFunctionInfo</span><span class="o">::</span><span class="n">iterator</span> <span class="n">PI</span> <span class="o">=</span> <span class="n">MD</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
                                  <span class="n">PE</span> <span class="o">=</span> <span class="n">MD</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">PI</span> <span class="o">!=</span> <span class="n">PE</span><span class="p">;</span> <span class="o">++</span><span class="n">PI</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Emit the address of the safe point.</span>
      <span class="n">OS</span><span class="p">.</span><span class="n">AddComment</span><span class="p">(</span><span class="s">&quot;safe point address&quot;</span><span class="p">);</span>
      <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Label</span> <span class="o">=</span> <span class="n">PI</span><span class="o">-&gt;</span><span class="n">Label</span><span class="p">;</span>
      <span class="n">AP</span><span class="p">.</span><span class="n">EmitLabelPlusOffset</span><span class="p">(</span><span class="n">Label</span><span class="cm">/*Hi*/</span><span class="p">,</span> <span class="mi">0</span><span class="cm">/*Offset*/</span><span class="p">,</span> <span class="mi">4</span><span class="cm">/*Size*/</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Stack information never change in safe points! Only print info from the</span>
    <span class="c1">// first call-site.</span>
    <span class="n">GCFunctionInfo</span><span class="o">::</span><span class="n">iterator</span> <span class="n">PI</span> <span class="o">=</span> <span class="n">MD</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

    <span class="c1">// Emit the stack frame size.</span>
    <span class="n">OS</span><span class="p">.</span><span class="n">AddComment</span><span class="p">(</span><span class="s">&quot;stack frame size (in words)&quot;</span><span class="p">);</span>
    <span class="n">AP</span><span class="p">.</span><span class="n">EmitInt32</span><span class="p">(</span><span class="n">MD</span><span class="p">.</span><span class="n">getFrameSize</span><span class="p">()</span> <span class="o">/</span> <span class="n">IntPtrSize</span><span class="p">);</span>

    <span class="c1">// Emit stack arity, i.e. the number of stacked arguments.</span>
    <span class="kt">unsigned</span> <span class="n">RegisteredArgs</span> <span class="o">=</span> <span class="n">IntPtrSize</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">?</span> <span class="mi">5</span> <span class="o">:</span> <span class="mi">6</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">StackArity</span> <span class="o">=</span> <span class="n">MD</span><span class="p">.</span><span class="n">getFunction</span><span class="p">().</span><span class="n">arg_size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">RegisteredArgs</span> <span class="o">?</span>
                          <span class="n">MD</span><span class="p">.</span><span class="n">getFunction</span><span class="p">().</span><span class="n">arg_size</span><span class="p">()</span> <span class="o">-</span> <span class="nl">RegisteredArgs</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">OS</span><span class="p">.</span><span class="n">AddComment</span><span class="p">(</span><span class="s">&quot;stack arity&quot;</span><span class="p">);</span>
    <span class="n">AP</span><span class="p">.</span><span class="n">EmitInt32</span><span class="p">(</span><span class="n">StackArity</span><span class="p">);</span>

    <span class="c1">// Emit the number of live roots in the function.</span>
    <span class="n">OS</span><span class="p">.</span><span class="n">AddComment</span><span class="p">(</span><span class="s">&quot;live root count&quot;</span><span class="p">);</span>
    <span class="n">AP</span><span class="p">.</span><span class="n">EmitInt32</span><span class="p">(</span><span class="n">MD</span><span class="p">.</span><span class="n">live_size</span><span class="p">(</span><span class="n">PI</span><span class="p">));</span>

    <span class="c1">// And for each live root...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">GCFunctionInfo</span><span class="o">::</span><span class="n">live_iterator</span> <span class="n">LI</span> <span class="o">=</span> <span class="n">MD</span><span class="p">.</span><span class="n">live_begin</span><span class="p">(</span><span class="n">PI</span><span class="p">),</span>
                                       <span class="n">LE</span> <span class="o">=</span> <span class="n">MD</span><span class="p">.</span><span class="n">live_end</span><span class="p">(</span><span class="n">PI</span><span class="p">);</span>
                                       <span class="n">LI</span> <span class="o">!=</span> <span class="n">LE</span><span class="p">;</span> <span class="o">++</span><span class="n">LI</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Emit live root&#39;s offset within the stack frame.</span>
      <span class="n">OS</span><span class="p">.</span><span class="n">AddComment</span><span class="p">(</span><span class="s">&quot;stack index (offset / wordsize)&quot;</span><span class="p">);</span>
      <span class="n">AP</span><span class="p">.</span><span class="n">EmitInt32</span><span class="p">(</span><span class="n">LI</span><span class="o">-&gt;</span><span class="n">StackOffset</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="references">
<h2><a class="toc-backref" href="#id29">参考文献</a><a class="headerlink" href="#references" title="永久链接至标题">¶</a></h2>
<p id="appel89">[Appel89] Runtime Tags Aren’t Necessary. Andrew W. Appel. Lisp and Symbolic
Computation 19(7):703-705, July 1989.</p>
<p id="goldberg91">[Goldberg91] Tag-free garbage collection for strongly typed programming
languages. Benjamin Goldberg. ACM SIGPLAN PLDI‘91.</p>
<p id="tolmach94">[Tolmach94] Tag-free garbage collection using explicit type parameters. Andrew
Tolmach. Proceedings of the 1994 ACM conference on LISP and functional
programming.</p>
<p id="henderson02">[Henderson2002] <a class="reference external" href="http://citeseer.ist.psu.edu/henderson02accurate.html">Accurate Garbage Collection in an Uncooperative Environment</a></p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="WritingAnLLVMPass.html" title="Writing an LLVM Pass"
             >下一页</a> |</li>
        <li class="right" >
          <a href="HowToUseInstrMappings.html" title="How To Use Instruction Mappings"
             >上一页</a> |</li>
  <li><a href="http://llvm.org/">LLVM 官网</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">LLVM 中文文档</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2018, LLVM Project.
      最后更新于 2018-01-14.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.6 创建。
    </div>
  </body>
</html>